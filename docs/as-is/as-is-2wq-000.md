# AS-IS Document: 2WQ-000 - Demo para José

> **Document Purpose**: This document captures the current state of the project as it exists today. It serves as a reference point for understanding what we have before planning any migrations or changes.

---

## 1. Project Information

### Project Overview
**Project Code**: 2WQ-000

**Project Name**: Demo para José

**Project Description**:
This is a demonstration repository that showcases multiple approaches to building Java microservices architectures using modern Spring technologies. The project contains five different example implementations that demonstrate various architectural patterns, from basic microservices to advanced reactive systems with cloud-native deployment capabilities. Each example serves as a learning resource and reference implementation for building scalable, distributed applications with different levels of complexity and feature sets.

**Main Use Cases**:
- **Educational Reference**: Provides working examples of microservices architectures using Spring Boot and Spring Cloud for training and learning purposes
- **Architecture Comparison**: Demonstrates different approaches to building microservices (traditional vs. reactive, various gateway patterns, container orchestration)
- **API Gateway Pattern**: Shows how to implement centralized routing and authentication through gateway services
- **Service Discovery**: Demonstrates automatic service registration and discovery using Netflix Eureka
- **Cloud-Native Deployment**: Showcases deployment to container platforms including Docker Compose and Kubernetes

### Project Team

**Current Project Owner**: Not assigned

**Current Technical Lead**: Not assigned

**Team Members**: 
This is a demonstration and training project based on Okta developer examples.

---

## 2. Technical Details

### Technologies Used

List all technologies, frameworks, and tools currently in use:

| Technology | Version | Purpose |
|------------|---------|---------|
| Java | 11 | Primary programming language for all services |
| Spring Boot | 2.1.4.RELEASE - 2.2.5.RELEASE | Framework for building microservices and REST APIs |
| Spring Cloud | Hoxton.SR10 | Framework for distributed systems patterns and cloud-native features |
| JHipster | 6.0.1 - 7.x | Development platform for generating and managing microservices applications |
| Netflix Eureka | Latest (via Spring Cloud) | Service discovery and registry for microservices |
| Netflix Zuul | Latest (via Spring Cloud) | API Gateway for routing and filtering requests (older examples) |
| Spring Cloud Gateway | Latest | Modern reactive API gateway (newer examples) |
| Spring WebFlux | Latest | Reactive web framework for non-blocking applications |
| PostgreSQL | 11.2 | Relational database for gateway and blog services |
| MongoDB | 4.0.9 | NoSQL database for store service data |
| Neo4j | Latest | Graph database for blog service (reactive example) |
| Keycloak | Latest | Open-source identity and access management solution |
| Okta | Latest | Cloud-based authentication and authorization service |
| Docker | Latest | Container platform for packaging and deploying services |
| Kubernetes | Latest | Container orchestration platform for cloud deployment |
| Maven | 3.0.0+ | Build automation and dependency management tool |
| Gradle | Latest | Alternative build tool (used in reactive examples) |
| Prometheus | Latest | Monitoring and metrics collection system |
| Grafana | Latest | Metrics visualization and monitoring dashboard |

### Solution Architecture

**Architecture Overview**:
The project contains five distinct architectural examples, each demonstrating a different approach to building microservices:

1. **Basic Spring Boot + Spring Cloud**: A foundational microservices architecture with Eureka for service discovery, Zuul as an API gateway, and OAuth 2.0 security. This is the simplest implementation showing core concepts.

2. **JHipster + Spring Cloud Config**: An enhanced architecture generated with JHipster that adds centralized configuration management using Spring Cloud Config. This demonstrates enterprise-ready patterns with the JHipster Registry.

3. **Spring Cloud Gateway (Reactive)**: A modern reactive architecture using Spring Cloud Gateway instead of Zuul, with Spring WebFlux for non-blocking, reactive operations. This shows how to build high-performance, scalable services.

4. **Reactive JHipster**: A complete reactive microservices implementation generated by JHipster, combining the benefits of code generation with reactive programming patterns.

5. **Kubernetes Deployment**: A cloud-native implementation showing how to deploy JHipster microservices to Kubernetes on Google Cloud, including sealed secrets management for production security.

All architectures follow common patterns: API Gateway for routing, service discovery for dynamic service location, and OAuth 2.0 for security.

**Architecture Diagram**:
```
Example 1 & 2: Traditional Architecture
┌─────────────────────────────────────────────────────────────┐
│                     Client Applications                      │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
            ┌──────────────────┐
            │   API Gateway    │ (Port 8080)
            │  (Zuul/Gateway)  │
            └────────┬─────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
        ▼            ▼            ▼
   ┌────────┐  ┌────────┐  ┌────────┐
   │ Gateway│  │  Blog  │  │ Store  │
   │Service │  │Service │  │Service │
   └───┬────┘  └───┬────┘  └───┬────┘
       │           │            │
       ▼           ▼            ▼
  ┌─────────┐ ┌─────────┐ ┌─────────┐
  │PostgreSQL│ │PostgreSQL│ │ MongoDB │
  └─────────┘ └─────────┘ └─────────┘
       
             ┌──────────────┐
             │   Eureka     │ (Port 8761)
             │   Registry   │
             └──────────────┘

             ┌──────────────┐
             │   Keycloak/  │ (Port 9080)
             │   Okta Auth  │
             └──────────────┘
```

**Key Components**:
- **Discovery Service (Eureka)**: Central service registry where all microservices register themselves. Other services can discover and communicate with registered services dynamically. Runs on port 8761.

- **API Gateway**: Entry point for all client requests. Routes traffic to appropriate microservices, handles authentication, and provides cross-cutting concerns like rate limiting. Runs on port 8080.

- **Gateway Service**: Manages the user interface and coordinates between microservices. Connects to PostgreSQL database for storing gateway-specific data.

- **Blog Service**: Handles blog post management functionality. In traditional examples uses PostgreSQL, in reactive examples uses Neo4j graph database for more complex data relationships.

- **Store Service**: Manages product/store information. Uses MongoDB for flexible, document-based data storage suitable for product catalogs.

- **JHipster Registry**: Enhanced Eureka registry that also provides Spring Cloud Config Server for centralized configuration management in JHipster examples.

- **Keycloak/Okta**: Identity and access management solutions for OAuth 2.0/OIDC authentication. Keycloak is self-hosted, Okta is cloud-based.

- **Monitoring Stack** (Optional): Prometheus for metrics collection and Grafana for visualization, integrated in JHipster examples.

**Deployment Information**:
- **Environment(s)**: Development (local), Production (prod profile for JHipster apps)
- **Hosting Location**: Currently designed for local development with Docker Compose, with Kubernetes examples targeting Google Cloud Platform
- **Number of Instances**: Typically 1 instance per service in development, scalable to multiple instances in Kubernetes deployments

---

## 3. Dependencies

This section lists all external systems, services, and resources that the project relies on to function properly.

### Databases

| Database Name | Type | Purpose | Connection Details |
|---------------|------|---------|-------------------|
| gateway-postgresql | PostgreSQL 11.2 | Stores gateway application data including user sessions and gateway-specific entities | Host: gateway-postgresql, Port: 5432, Database: gateway |
| blog-postgresql | PostgreSQL 11.2 | Stores blog posts, comments, and related content | Host: blog-postgresql, Port: 5432, Database: blog |
| store-mongodb | MongoDB 4.0.9 | Stores product catalog, inventory, and store-related documents | Host: store-mongodb, Port: 27017, Database: store |
| blog-neo4j | Neo4j (Latest) | Graph database for blog relationships in reactive examples | Host: blog-neo4j, Port: 7687 |

### Message Queues / Event Systems

This demonstration project does not use message queues or event streaming systems. Communication between services is synchronous via REST APIs.

### External Integrations

List any third-party services or external systems the project connects to:

| Integration Name | Purpose | Type | Credentials Required |
|------------------|---------|------|---------------------|
| Okta | OAuth 2.0 / OIDC authentication and authorization provider | Cloud Service / REST API | Yes - Client ID, Client Secret, Issuer URI |
| Keycloak | Self-hosted identity and access management (alternative to Okta) | Self-hosted Service | Yes - Client credentials configured in realm |
| JHipster Registry | Service registry and configuration server (extends Netflix Eureka) | Internal Service | Yes - Admin credentials |
| Google Cloud Platform | Kubernetes cluster hosting (for K8s example) | Cloud Service | Yes - GCP service account credentials |

### Other Dependencies

**Configuration Management**:
- Spring Cloud Config Server (part of JHipster Registry) for centralized configuration
- YAML configuration files for environment-specific settings (application.yml, application-dev.yml, application-prod.yml)
- Bootstrap configuration for service discovery and config server connection

**Development Tools**:
- Maven wrapper (./mvnw) for building Spring Boot applications
- Gradle wrapper (./gradlew) for building reactive applications
- Docker Compose for orchestrating multi-container applications
- JHipster CLI for generating and managing applications
- Jib Maven Plugin for building Docker images without Docker daemon

**Monitoring and Observability**:
- Spring Boot Actuator for health checks and metrics endpoints
- Prometheus for metrics collection
- Grafana for metrics visualization
- JHipster Console for centralized logging (optional)

---

## 4. Communication Matrix

This section documents all network communications between systems, including servers, ports, and protocols.

### Internal Communications

Communications between components within the project:

| Source Component | Destination Component | Protocol | Port | Direction | Purpose |
|------------------|----------------------|----------|------|-----------|---------|
| All Microservices | Eureka Registry | HTTP | 8761 | Outbound | Service registration and discovery |
| All Microservices | JHipster Registry / Config Server | HTTP | 8761 | Outbound | Fetch centralized configuration |
| API Gateway | Blog Service | HTTP | Dynamic | Outbound | Route blog-related requests |
| API Gateway | Store Service | HTTP | Dynamic | Outbound | Route store-related requests |
| Gateway Service | PostgreSQL | TCP | 5432 | Outbound | Database queries and transactions |
| Blog Service | PostgreSQL / Neo4j | TCP | 5432/7687 | Outbound | Database operations for blog data |
| Store Service | MongoDB | TCP | 27017 | Outbound | Database operations for store data |
| All Services | Prometheus | HTTP | 9090 | Inbound | Metrics scraping via /actuator/prometheus |

### External Communications

Communications with external systems or services:

| Source | Destination | Protocol | Port | Direction | Purpose | Notes |
|--------|-------------|----------|------|-----------|---------|-------|
| Client Browser | API Gateway | HTTP/HTTPS | 8080 | Inbound | Access all application functionality | Main entry point |
| Client Browser | Eureka Registry | HTTP | 8761 | Inbound | View service registry dashboard | Admin access |
| All Services | Okta | HTTPS | 443 | Outbound | OAuth 2.0 authentication and token validation | Requires Okta domain configuration |
| All Services | Keycloak | HTTP | 9080 | Outbound | OAuth 2.0 authentication (when using Keycloak) | Alternative to Okta |
| Kubernetes Pods | GCP Services | HTTPS | 443 | Outbound | Cloud platform management and monitoring | K8s example only |
| Developer Workstation | All Services | HTTP | Various | Bidirectional | Development and debugging | Local development only |

### Firewall Requirements

Firewall rules that must be configured for the application to work properly:

| Rule Description | Source | Destination | Port | Protocol |
|------------------|--------|-------------|------|----------|
| Allow Web Traffic to Gateway | Client Network | API Gateway | 8080 | HTTP/HTTPS |
| Allow Eureka Dashboard Access | Admin Network | Eureka Registry | 8761 | HTTP |
| Allow OAuth Provider | All Services | Okta/Keycloak | 443/9080 | HTTPS/HTTP |
| Allow Database Access (PostgreSQL) | Gateway/Blog Services | PostgreSQL Servers | 5432 | TCP |
| Allow Database Access (MongoDB) | Store Service | MongoDB Server | 27017 | TCP |
| Allow Database Access (Neo4j) | Blog Service | Neo4j Server | 7687 | TCP |
| Allow Metrics Collection | Prometheus | All Services | 8080-8999 | HTTP |
| Allow Cloud Management (K8s) | Kubernetes Cluster | GCP APIs | 443 | HTTPS |

---

## 5. Additional Information

### Current Challenges or Issues

**Demonstration Project Status**:
This is a collection of educational examples and not a production application. The following characteristics are important to note:
- The examples use demo credentials and simplified security configurations
- OAuth integration requires setting up Okta or Keycloak with proper client credentials
- Different examples use different versions of technologies, which may not all be compatible
- Some examples are maintained by the community and may become outdated over time

**Technology Version Considerations**:
- Java 11 is used, which is an older LTS version (current LTS is Java 17 or 21)
- Spring Boot versions range from 2.1.x to 2.2.x, which are not the latest versions
- JHipster 6.x and 7.x are used, newer versions may be available
- Netflix Zuul is deprecated in favor of Spring Cloud Gateway

**Security Considerations**:
- OAuth 2.0 credentials (client ID and secret) must be properly configured and secured
- Default admin passwords in registry services should be changed for any non-demo use
- Database connections in examples do not use passwords (suitable only for development)
- Keycloak default realm configurations should be customized for production
- API endpoints should implement proper rate limiting and input validation for production use

**Deployment Complexity**:
- Each of the five examples has different setup and deployment procedures
- Docker Compose is used for local development but requires significant resources
- Kubernetes deployment requires cloud infrastructure and additional configuration
- Multiple databases and supporting services must be running simultaneously

### Important Notes

**Repository Structure**:
The repository contains five separate example implementations:
1. `/spring-boot+cloud` - Basic Spring Boot and Spring Cloud implementation
2. `/jhipster` - JHipster generated apps with Spring Cloud Config
3. `/spring-cloud-gateway` - Reactive gateway implementation
4. `/reactive-jhipster` - Fully reactive JHipster implementation
5. `/jhipster-k8s` - Kubernetes deployment example with JHipster

**Configuration Files**:
- Each example has its own configuration in `application.yml` and `application.properties` files
- Docker Compose files are located in `/docker-compose` directories within each example
- Kubernetes manifests are in the `/k8s` directory for the Kubernetes example
- Centralized configuration for JHipster examples is in `/docker-compose/central-server-config/`

**Authentication Setup**:
- All examples require OAuth 2.0 configuration with either Okta or Keycloak
- Okta setup instructions are provided in README files
- Keycloak is pre-configured in Docker Compose files
- Group-based authorization (ROLE_ADMIN, ROLE_USER) is implemented

**Build and Run Instructions**:
- Traditional examples use Maven: `./mvnw` or `./mvnw spring-boot:run`
- Reactive examples use Gradle: `./gradlew` or `./gradlew bootRun`
- Docker images can be built with Jib: `mvn -Pprod verify com.google.cloud.tools:jib-maven-plugin:dockerBuild`
- Full stack can be started with Docker Compose: `docker-compose up -d`

**Learning Resources**:
- Each example directory contains README.md with specific setup instructions
- Blog posts are referenced for detailed explanations of each architecture
- Demo scripts (demo.adoc) are included for walking through the examples

---

**Document Version**: 1.0
**Last Updated**: October 17, 2024
**Updated By**: GitHub Copilot
